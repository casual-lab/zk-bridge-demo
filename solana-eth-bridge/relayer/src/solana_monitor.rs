use anyhow::Result;
use solana_client::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;
use std::sync::Arc;
use tokio::time::{sleep, Duration};
use tracing::{info, error, warn};

use crate::SolanaConfig;
use crate::prover::{Sp1Prover, types::{SolanaBlockData, ValidatorSignature}};

pub struct SolanaMonitor {
    rpc_url: String,
    min_confirmations: u32,
    poll_interval_ms: u64,
    client: RpcClient,
    prover: Arc<Sp1Prover>,
    enable_proving: bool, // æ˜¯å¦å¯ç”¨è¯æ˜ç”Ÿæˆï¼ˆå¼€å‘æ—¶å¯ä»¥å…³é—­ï¼‰
}

impl SolanaMonitor {
    pub fn new(config: SolanaConfig, prover: Arc<Sp1Prover>) -> Self {
        let client = RpcClient::new_with_commitment(
            config.rpc_url.clone(),
            CommitmentConfig::confirmed(),
        );
        
        info!("Solana monitor initialized: {}", config.rpc_url);
        
        Self {
            rpc_url: config.rpc_url,
            min_confirmations: config.min_confirmations,
            poll_interval_ms: config.poll_interval_ms,
            client,
            prover,
            enable_proving: false, // é»˜è®¤å…³é—­ï¼Œé¿å…åœ¨å¼€å‘æ—¶é¢‘ç¹ç”Ÿæˆè¯æ˜
        }
    }
    
    /// å¯ç”¨è¯æ˜ç”Ÿæˆ
    pub fn enable_proving(&mut self) {
        self.enable_proving = true;
        info!("âœ… Solana Monitor: Proof generation enabled");
    }

    pub async fn start(&self) -> Result<()> {
        info!("ğŸš€ Starting Solana monitor on {}", self.rpc_url);
        
        let mut last_slot = 0u64;
        
        loop {
            match self.check_new_blocks(&mut last_slot).await {
                Ok(_) => {}
                Err(e) => {
                    error!("âŒ Solana monitor error: {:?}", e);
                }
            }
            
            sleep(Duration::from_millis(self.poll_interval_ms)).await;
        }
    }

    async fn check_new_blocks(&self, last_slot: &mut u64) -> Result<()> {
        // è·å–å½“å‰ slot
        let current_slot = self.client.get_slot()?;
        
        if current_slot > *last_slot {
            // è®¡ç®—ç¡®è®¤çš„ slotï¼ˆå‡å»ç¡®è®¤æ·±åº¦ï¼‰
            let confirmed_slot = current_slot.saturating_sub(self.min_confirmations as u64);
            
            if confirmed_slot > *last_slot {
                info!(
                    "ğŸ“¦ New confirmed Solana slot: {} (current: {}, confirmations: {})",
                    confirmed_slot, current_slot, self.min_confirmations
                );
                
                // è·å–åŒºå—æ•°æ®
                if let Err(e) = self.process_new_slot(confirmed_slot).await {
                    error!("âŒ Failed to process Solana slot {}: {:?}", confirmed_slot, e);
                }
                
                *last_slot = confirmed_slot;
            }
        }
        
        Ok(())
    }
    
    /// å¤„ç†æ–°çš„ Solana slot
    async fn process_new_slot(&self, slot: u64) -> Result<()> {
        // 1. è·å–åŒºå—æ•°æ® (ç®€åŒ–ç‰ˆï¼Œå®é™…éœ€è¦æ›´å¤šæ•°æ®)
        let blockhash = self.get_recent_blockhash()?;
        
        // 2. æ„é€ åŒºå—æ•°æ®
        let block_data = SolanaBlockData {
            slot,
            parent_slot: slot.saturating_sub(1),
            blockhash: self.hash_to_bytes32(&blockhash),
            parent_hash: [0u8; 32], // ç®€åŒ–ï¼šå®é™…éœ€è¦ä»çˆ¶åŒºå—è·å–
            signatures: vec![
                // ç®€åŒ–ï¼šå®é™…éœ€è¦ä»åŒºå—è·å–çœŸå®çš„éªŒè¯è€…ç­¾å
                ValidatorSignature {
                    validator_pubkey: [1u8; 32],
                    signature: vec![1u8; 64],
                },
            ],
        };
        
        info!("ğŸ“ Solana block data prepared: slot {}", slot);
        
        // 3. ç”Ÿæˆè¯æ˜ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if self.enable_proving {
            info!("ğŸ”¬ Generating ZK proof for Solana slot {}...", slot);
            
            match self.prover.prove_solana_block(&block_data) {
                Ok(proof) => {
                    info!(
                        "âœ… Proof generated for Solana slot {}: {} bytes ({})",
                        slot, proof.proof_bytes.len(), 
                        if proof.proof_type == crate::prover::types::ProofType::Groth16 { "Groth16" } else { "STARK" }
                    );
                    
                    // TODO: Task 3 - æäº¤è¯æ˜åˆ° Ethereum
                    info!("ğŸ“¤ TODO: Submit proof to Ethereum SolanaUpdater contract");
                }
                Err(e) => {
                    error!("âŒ Failed to generate proof for Solana slot {}: {}", slot, e);
                }
            }
        } else {
            warn!("âš ï¸  Proof generation disabled. Enable with enable_proving()");
        }
        
        Ok(())
    }
    
    /// è·å–æœ€è¿‘çš„ blockhash (è¾…åŠ©æ–¹æ³•)
    fn get_recent_blockhash(&self) -> Result<String> {
        // ç®€åŒ–å®ç°ï¼šå®é™…åº”è¯¥è·å–ç‰¹å®š slot çš„ blockhash
        let hash = self.client.get_latest_blockhash()?;
        Ok(hash.to_string())
    }
    
    /// å°†å­—ç¬¦ä¸² hash è½¬æ¢ä¸º [u8; 32]
    fn hash_to_bytes32(&self, hash_str: &str) -> [u8; 32] {
        let mut result = [0u8; 32];
        if let Ok(bytes) = bs58::decode(hash_str).into_vec() {
            let len = bytes.len().min(32);
            result[..len].copy_from_slice(&bytes[..len]);
        }
        result
    }

    /// è·å–å½“å‰ slotï¼ˆç”¨äºæµ‹è¯•ï¼‰
    #[allow(dead_code)]
    pub fn get_current_slot(&self) -> Result<u64> {
        Ok(self.client.get_slot()?)
    }
}
