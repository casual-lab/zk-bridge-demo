# å–æ¶ˆè¶…æ—¶é€€æ¬¾æœºåˆ¶çš„è®¾è®¡å†³ç­–

## å†³ç­–æ¦‚è¿°

**æ—¥æœŸ**: 2025-11-01  
**å†³ç­–**: å½»åº•å–æ¶ˆè¶…æ—¶é€€æ¬¾ï¼ˆrefund_timeoutï¼‰æœºåˆ¶  
**åŸå› **: æ¶ˆé™¤ç«æ€æ¡ä»¶æ¼æ´ï¼Œå‘ LayerZero/Wormhole å®‰å…¨æ¨¡å‹é æ‹¢

---

## 1. å†³ç­–ç†ç”±

### å®‰å…¨æ€§ä¼˜å…ˆ

```
å…è®¸è¶…æ—¶é€€æ¬¾çš„é£é™©çª—å£ï¼š

T0: ç”¨æˆ·åœ¨ Solana é”å®š 100 USDC
T1: Relayer è·å–æ•°æ®å¹¶ç”Ÿæˆ ZK è¯æ˜ï¼ˆè€—æ—¶ 5 åˆ†é’Ÿï¼‰
T2: ç”¨æˆ·è°ƒç”¨ refund_timeoutï¼ˆ10 åˆ†é’Ÿåï¼‰
T3: Relayer æäº¤è¯æ˜åˆ° EVM é“¾
â†’ ç»“æœï¼šç”¨æˆ·æ‹¿å› 100 USDC + åœ¨ EVM è·å¾— 100 USDC = åŒèŠ±ï¼

å³ä½¿æ·»åŠ ï¼š
- âŒ æ—¶é—´çª—å£æ£€æŸ¥ï¼ˆä»æœ‰å‡ åˆ†é’Ÿç«äº‰çª—å£ï¼‰
- âŒ æŒ‘æˆ˜æœŸæœºåˆ¶ï¼ˆå¢åŠ å¤æ‚åº¦ï¼Œä»æœ‰é£é™©ï¼‰
- âŒ çŠ¶æ€æ ¹éªŒè¯ï¼ˆéœ€è¦ light clientï¼Œæˆæœ¬é«˜ï¼‰

æ ¹æœ¬é—®é¢˜ï¼šé€€æ¬¾å’Œè¯æ˜æäº¤æ˜¯ä¸¤ä¸ªç‹¬ç«‹æ“ä½œï¼Œæ— æ³•åŸå­åŒ–
```

### ä¸»æµåè®®çš„é€‰æ‹©

| åè®® | æ˜¯å¦æ”¯æŒè¶…æ—¶é€€æ¬¾ | æ´»è·ƒæ€§ä¿è¯ |
|------|-----------------|-----------|
| **LayerZero** | âŒ ä¸æ”¯æŒ | Oracle + Relayer ç»æµæ¿€åŠ± |
| **Wormhole** | âŒ ä¸æ”¯æŒ | 19 Guardian å¤šç­¾ + è´¨æŠ¼ |
| **Across** | âŒ ä¸æ”¯æŒ | LP æ±  + Relayer ç«äº‰ |
| **Synapse** | âŒ ä¸æ”¯æŒ | AMM æ±  + è·¨é“¾éªŒè¯ |
| **æˆ‘ä»¬** | âœ… **ä¸æ”¯æŒ** | **ZK è¯æ˜ + Relayer æ¿€åŠ±** |

**è¡Œä¸šå…±è¯†**ï¼šè·¨é“¾æ¡¥ä¸åº”è¯¥æ”¯æŒé€€æ¬¾ï¼Œè€Œæ˜¯ä¿è¯æ¶ˆæ¯æœ€ç»ˆé€è¾¾ã€‚

---

## 2. æ–°çš„è®¾è®¡æ–¹æ¡ˆ

### æ ¸å¿ƒåŸåˆ™

**"æ¶ˆæ¯è¦ä¹ˆæˆåŠŸï¼Œè¦ä¹ˆæ°¸ä¹… pendingï¼Œä½†ç»ä¸å…è®¸åŒèŠ±"**

### æ•°æ®ç»“æ„ç®€åŒ–

```rust
// ç§»é™¤è¶…æ—¶ç›¸å…³å­—æ®µ
#[account]
pub struct TransferOrder {
    pub order_id: u64,                    // è®¢å• ID
    pub user: Pubkey,                     // ç”¨æˆ·åœ°å€
    pub status: OrderStatus,              // Pending | Completed
    pub token_mint: Pubkey,               // SPL Token Mint
    pub amount: u64,                      // é”å®šæ•°é‡
    pub recipient: [u8; 20],              // EVM æ¥æ”¶åœ°å€
    pub created_slot: u64,                // åˆ›å»ºæ—¶é—´
    // âŒ ç§»é™¤ timeout_slot
    // âŒ ç§»é™¤ refunded_slot
    pub proof_hash: [u8; 32],             // ZK è¯æ˜å“ˆå¸Œ
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum OrderStatus {
    Pending,      // ç­‰å¾… Relayer å¤„ç†
    Completed,    // å·²å®Œæˆ
    // âŒ ç§»é™¤ Refunded çŠ¶æ€
}

// Space: 8 + 8 + 32 + 1 + 32 + 8 + 20 + 8 + 32 = 149 bytes
```

### çŠ¶æ€æœºç®€åŒ–

```
åŸè®¾è®¡ï¼ˆ3 çŠ¶æ€ï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  unlock_tokens   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Pending â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚ Completed â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                              â†‘
     â”‚ refund_timeout               â”‚
     â†“                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  challenge_refund      â”‚
â”‚ Refunded â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


æ–°è®¾è®¡ï¼ˆ2 çŠ¶æ€ï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  unlock_tokens   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Pending â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚ Completed â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†‘                              
     â”‚ (æ°¸ä¹…ç­‰å¾… Relayer)            
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

## 3. æ´»è·ƒæ€§ä¿è¯æœºåˆ¶

### Phase 1-2: åŸºç¡€ Relayer æ¿€åŠ±

```rust
#[account]
pub struct BridgeConfig {
    pub authority: Pubkey,
    pub paused: bool,
    
    // Relayer æ¿€åŠ±æœºåˆ¶
    pub relayer_fee_bps: u16,        // Relayer æ‰‹ç»­è´¹ï¼ˆåŸºç‚¹ï¼Œä¾‹å¦‚ 10 = 0.1%ï¼‰
    pub relayer_reward_pool: Pubkey,  // Relayer å¥–åŠ±æ± 
}

#[derive(Accounts)]
pub struct UnlockTokens<'info> {
    // ... å…¶ä»–è´¦æˆ·
    
    #[account(mut)]
    pub relayer: Signer<'info>,      // Relayer ç­¾å
    
    #[account(
        mut,
        seeds = [b"relayer_reward_pool"],
        bump
    )]
    pub reward_pool: Account<'info, TokenAccount>,
}

pub fn unlock_tokens(
    ctx: Context<UnlockTokens>,
    order_id: u64,
    proof_hash: [u8; 32],
) -> Result<()> {
    // 1. éªŒè¯è¯æ˜
    require!(proof_hash != [0u8; 32], BridgeError::InvalidProof);
    
    // 2. è®¡ç®— Relayer å¥–åŠ±
    let fee_amount = order.amount
        .checked_mul(ctx.accounts.bridge_config.relayer_fee_bps as u64)
        .unwrap()
        .checked_div(10000)
        .unwrap();
    
    let user_amount = order.amount.checked_sub(fee_amount).unwrap();
    
    // 3. è½¬è´¦ç»™ç”¨æˆ·
    let seeds = &[b"bridge_config".as_ref(), &[ctx.bumps.bridge_config]];
    let signer_seeds = &[&seeds[..]];
    
    token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.vault.to_account_info(),
                to: ctx.accounts.user_token_account.to_account_info(),
                authority: ctx.accounts.bridge_config.to_account_info(),
            },
            signer_seeds,
        ),
        user_amount,
    )?;
    
    // 4. å¥–åŠ±ç»™ Relayer
    token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.vault.to_account_info(),
                to: ctx.accounts.reward_pool.to_account_info(),
                authority: ctx.accounts.bridge_config.to_account_info(),
            },
            signer_seeds,
        ),
        fee_amount,
    )?;
    
    // 5. æ›´æ–°çŠ¶æ€
    order.status = OrderStatus::Completed;
    order.proof_hash = proof_hash;
    
    emit!(TokensUnlocked {
        order_id,
        user: order.user,
        amount: user_amount,
        relayer_fee: fee_amount,
        relayer: ctx.accounts.relayer.key(),
    });
    
    Ok(())
}
```

### Phase 3-4: å»ä¸­å¿ƒåŒ– Relayer ç½‘ç»œ

```rust
#[account]
pub struct RelayerInfo {
    pub relayer: Pubkey,
    pub stake_amount: u64,          // è´¨æŠ¼é‡‘é¢
    pub successful_relays: u64,     // æˆåŠŸä¸­ç»§æ¬¡æ•°
    pub failed_relays: u64,         // å¤±è´¥æ¬¡æ•°
    pub reputation_score: u64,      // ä¿¡èª‰åˆ†æ•°
    pub is_active: bool,
}

pub fn register_relayer(
    ctx: Context<RegisterRelayer>,
    stake_amount: u64,
) -> Result<()> {
    require!(stake_amount >= MIN_RELAYER_STAKE, BridgeError::InsufficientStake);
    
    // è´¨æŠ¼ä»£å¸
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.relayer_token_account.to_account_info(),
                to: ctx.accounts.stake_pool.to_account_info(),
                authority: ctx.accounts.relayer.to_account_info(),
            },
        ),
        stake_amount,
    )?;
    
    // åˆå§‹åŒ– Relayer ä¿¡æ¯
    ctx.accounts.relayer_info.relayer = ctx.accounts.relayer.key();
    ctx.accounts.relayer_info.stake_amount = stake_amount;
    ctx.accounts.relayer_info.is_active = true;
    ctx.accounts.relayer_info.reputation_score = 100;
    
    Ok(())
}

pub fn slash_relayer(
    ctx: Context<SlashRelayer>,
    reason: String,
) -> Result<()> {
    // ä»… authority å¯ä»¥ slash
    require!(
        ctx.accounts.authority.key() == ctx.accounts.bridge_config.authority,
        BridgeError::Unauthorized
    );
    
    // æ‰£é™¤è´¨æŠ¼
    let slash_amount = ctx.accounts.relayer_info.stake_amount / 10; // 10%
    
    // è½¬å…¥å›½åº“
    // ...
    
    ctx.accounts.relayer_info.stake_amount -= slash_amount;
    ctx.accounts.relayer_info.failed_relays += 1;
    
    emit!(RelayerSlashed {
        relayer: ctx.accounts.relayer_info.relayer,
        amount: slash_amount,
        reason,
    });
    
    Ok(())
}
```

### Phase 5+: å¤š Relayer ç«äº‰

```rust
pub struct TransferOrder {
    // ... å…¶ä»–å­—æ®µ
    
    pub relayer_commitments: Vec<RelayerCommitment>,  // å¤šä¸ª Relayer æ‰¿è¯º
}

pub struct RelayerCommitment {
    pub relayer: Pubkey,
    pub committed_slot: u64,
    pub estimated_completion_slot: u64,
}

pub fn commit_to_relay(
    ctx: Context<CommitToRelay>,
    order_id: u64,
    estimated_completion: u64,
) -> Result<()> {
    // Relayer æ‰¿è¯ºå¤„ç†è¯¥è®¢å•
    // å¦‚æœè¶…æ—¶æœªå®Œæˆï¼Œé™ä½ä¿¡èª‰åˆ†æ•°
    // ç¬¬ä¸€ä¸ªå®Œæˆçš„ Relayer è·å¾—å¥–åŠ±
    
    Ok(())
}
```

---

## 4. ç”¨æˆ·ä½“éªŒæ”¹è¿›

### é—®é¢˜ï¼šæ¶ˆæ¯å¯èƒ½æ°¸ä¹… pendingï¼Ÿ

**è§£å†³æ–¹æ¡ˆ 1: è®¢å•çŠ¶æ€æŸ¥è¯¢ API**

```typescript
// Relayer æœåŠ¡æä¾›æŸ¥è¯¢æ¥å£
interface OrderStatus {
  orderId: number;
  status: 'pending' | 'processing' | 'completed';
  estimatedCompletionTime?: number;  // é¢„è®¡å®Œæˆæ—¶é—´
  currentRelayer?: string;           // å½“å‰å¤„ç†çš„ Relayer
  retryCount: number;                // é‡è¯•æ¬¡æ•°
}

app.get('/api/order/:orderId', async (req, res) => {
  const order = await getOrderStatus(req.params.orderId);
  res.json(order);
});
```

**è§£å†³æ–¹æ¡ˆ 2: å¤š Relayer å†—ä½™**

```typescript
// åŒæ—¶å¹¿æ’­ç»™å¤šä¸ª Relayer
const relayers = [
  'https://relayer1.bridge.com',
  'https://relayer2.bridge.com',
  'https://relayer3.bridge.com',
];

async function submitOrder(order: Order) {
  // å¹¶å‘æäº¤ç»™æ‰€æœ‰ Relayer
  const promises = relayers.map(url => 
    fetch(`${url}/submit`, { 
      method: 'POST', 
      body: JSON.stringify(order) 
    })
  );
  
  // åªè¦æœ‰ä¸€ä¸ªæˆåŠŸå³å¯
  await Promise.race(promises);
}
```

**è§£å†³æ–¹æ¡ˆ 3: ç”¨æˆ·é€šçŸ¥ç³»ç»Ÿ**

```typescript
// WebSocket å®æ—¶é€šçŸ¥
const ws = new WebSocket('wss://bridge.com/orders');

ws.on('message', (data) => {
  const event = JSON.parse(data);
  
  if (event.orderId === myOrderId) {
    switch (event.type) {
      case 'relayer_assigned':
        showNotification('Relayer å·²æ¥å•');
        break;
      case 'proof_generating':
        showNotification('æ­£åœ¨ç”Ÿæˆ ZK è¯æ˜...');
        break;
      case 'proof_submitting':
        showNotification('æ­£åœ¨æäº¤è¯æ˜åˆ°ç›®æ ‡é“¾...');
        break;
      case 'completed':
        showNotification('âœ… è½¬è´¦å®Œæˆï¼');
        break;
    }
  }
});
```

### æç«¯æƒ…å†µå¤„ç†

**åœºæ™¯ 1: æ‰€æœ‰ Relayer éƒ½ç¦»çº¿**

```typescript
// å‰ç«¯æ£€æµ‹
async function checkRelayerHealth() {
  const healthChecks = await Promise.all(
    relayers.map(url => fetch(`${url}/health`))
  );
  
  const activeRelayers = healthChecks.filter(r => r.ok);
  
  if (activeRelayers.length === 0) {
    showWarning(
      'âš ï¸ Relayer ç½‘ç»œæš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•ã€‚\n' +
      'ä½ çš„èµ„é‡‘å®‰å…¨ï¼Œå·²é”å®šåœ¨æ™ºèƒ½åˆçº¦ä¸­ã€‚'
    );
    return false;
  }
  
  return true;
}
```

**åœºæ™¯ 2: Relayer æ¶æ„ä¸å¤„ç†**

```rust
// æ·»åŠ å…¬å…±ä¸­ç»§åŠŸèƒ½ï¼ˆä»»ä½•äººéƒ½å¯ä»¥ä¸­ç»§ï¼‰
pub fn public_relay(
    ctx: Context<PublicRelay>,
    order_id: u64,
    proof_hash: [u8; 32],
) -> Result<()> {
    let order = &ctx.accounts.transfer_order;
    
    // åªæœ‰åœ¨è®¢å•åˆ›å»ºè¶…è¿‡ 24 å°æ—¶åï¼Œæ‰å…è®¸å…¬å…±ä¸­ç»§
    let clock = Clock::get()?;
    let min_age_slots = 24 * 60 * 60 / 0.4; // 24 å°æ—¶
    
    require!(
        clock.slot >= order.created_slot + min_age_slots,
        BridgeError::OrderTooYoung
    );
    
    // å…¬å…±ä¸­ç»§è€…ä¹Ÿèƒ½è·å¾—å¥–åŠ±
    // ...
    
    Ok(())
}
```

**åœºæ™¯ 3: ç”¨æˆ·ç´§æ€¥å–æ¶ˆï¼ˆç‰¹æ®Šæƒ…å†µï¼‰**

```rust
// ä»…åœ¨æç‰¹æ®Šæƒ…å†µä¸‹å…è®¸ï¼ˆéœ€è¦ DAO æŠ•ç¥¨ï¼‰
pub fn emergency_cancel(
    ctx: Context<EmergencyCancel>,
    order_id: u64,
    governance_approval: [u8; 64], // DAO å¤šç­¾
) -> Result<()> {
    // éªŒè¯ DAO ç­¾å
    verify_dao_signature(governance_approval)?;
    
    // åªèƒ½å–æ¶ˆ pending è¶…è¿‡ 30 å¤©çš„è®¢å•
    let order = &ctx.accounts.transfer_order;
    require!(
        Clock::get()?.slot >= order.created_slot + 30 * 24 * 60 * 60 / 0.4,
        BridgeError::NotEligibleForEmergencyCancel
    );
    
    // é€€æ¬¾ç»™ç”¨æˆ·ï¼ˆéœ€è¦ DAO æ‰¹å‡†ï¼‰
    // ...
    
    emit!(EmergencyCancellation {
        order_id,
        reason: "DAO approved emergency cancellation",
    });
    
    Ok(())
}
```

---

## 5. Phase 1.4 æ–°å®æ–½è®¡åˆ’

### âŒ ä¸å†å®æ–½ refund_timeout

åŸè®¡åˆ’ Phase 1.4 æ˜¯å®ç°è¶…æ—¶é€€æ¬¾ï¼Œç°åœ¨å–æ¶ˆã€‚

### âœ… æ–°çš„ Phase 1.4ï¼šRelayer åŸºç¡€æ¶æ„

**ç›®æ ‡**ï¼š
1. å®ç° Relayer æ‰‹ç»­è´¹æœºåˆ¶
2. æ·»åŠ è®¢å•æŸ¥è¯¢åŠŸèƒ½
3. å»ºç«‹åŸºç¡€ç›‘æ§

**ä»»åŠ¡åˆ—è¡¨**ï¼š

#### 1. æ›´æ–° BridgeConfig
```rust
pub struct BridgeConfig {
    pub authority: Pubkey,
    pub paused: bool,
    pub relayer_fee_bps: u16,       // æ–°å¢
}
```

#### 2. ä¿®æ”¹ unlock_tokens
```rust
// æ·»åŠ  Relayer æ‰‹ç»­è´¹æ‰£é™¤é€»è¾‘
// æ·»åŠ  Relayer åœ°å€è®°å½•
// æ›´æ–°äº‹ä»¶å‚æ•°
```

#### 3. æ·»åŠ æŸ¥è¯¢æŒ‡ä»¤
```rust
pub fn get_order_info(
    ctx: Context<GetOrderInfo>,
    order_id: u64,
) -> Result<OrderInfo> {
    // è¿”å›è®¢å•è¯¦ç»†ä¿¡æ¯
}
```

#### 4. æµ‹è¯•ç”¨ä¾‹
```typescript
it("Relayer receives fee when unlocking tokens", async () => {
  // æµ‹è¯• Relayer è·å¾—æ‰‹ç»­è´¹
});

it("Cannot unlock already completed order", async () => {
  // æµ‹è¯•é‡æ”¾ä¿æŠ¤
});
```

---

## 6. é£é™©è¯„ä¼°ä¸ç¼“è§£

### é£é™© 1: Relayer å•ç‚¹æ•…éšœ

**ç¼“è§£æªæ–½**ï¼š
- âœ… Phase 1-2: è¿è¡Œå¤šä¸ª Relayer å®ä¾‹ï¼ˆå†—ä½™ï¼‰
- âœ… Phase 3+: å»ä¸­å¿ƒåŒ– Relayer ç½‘ç»œ
- âœ… Phase 5+: ä»»ä½•äººéƒ½å¯ä»¥æˆä¸º Relayer

### é£é™© 2: æ¶ˆæ¯å»¶è¿Ÿ

**ç¼“è§£æªæ–½**ï¼š
- âœ… Relayer æ‰‹ç»­è´¹æ¿€åŠ±
- âœ… å®æ—¶çŠ¶æ€æŸ¥è¯¢ API
- âœ… å‰ç«¯æ˜¾ç¤ºé¢„è®¡å®Œæˆæ—¶é—´
- âœ… WebSocket æ¨é€é€šçŸ¥

### é£é™© 3: ç”¨æˆ·èµ„é‡‘"å¡ä½"

**ç¼“è§£æªæ–½**ï¼š
- âœ… å…¬å…±ä¸­ç»§åŠŸèƒ½ï¼ˆ24 å°æ—¶åï¼‰
- âœ… DAO ç´§æ€¥å–æ¶ˆï¼ˆ30 å¤©åï¼‰
- âœ… å¤š Relayer ç«äº‰æœºåˆ¶
- âœ… æ¸…æ™°çš„ç”¨æˆ·æç¤ºå’Œæ–‡æ¡£

### é£é™© 4: Relayer å®¡æŸ¥

**ç¼“è§£æªæ–½**ï¼š
- âœ… æ— éœ€è®¸å¯çš„ Relayer æ³¨å†Œ
- âœ… ä»»ä½•äººéƒ½å¯ä»¥è¿è¡Œ Relayer
- âœ… ç»æµæ¿€åŠ±ä¿è¯ç«äº‰
- âœ… å…¬å…±ä¸­ç»§ä½œä¸ºæœ€åæ‰‹æ®µ

---

## 7. ä¸ç«å“å¯¹æ¯”

### å®‰å…¨æ€§

| åè®® | åŒèŠ±é£é™© | é‡æ”¾ä¿æŠ¤ | è¯„çº§ |
|------|---------|---------|------|
| LayerZero | âœ… æ—  | âœ… Nonce | A+ |
| Wormhole | âœ… æ—  | âœ… VAA Hash | A+ |
| **æˆ‘ä»¬ï¼ˆæ–°è®¾è®¡ï¼‰** | âœ… **æ— ** | âœ… **Order ID + Status** | **A+** |
| æˆ‘ä»¬ï¼ˆæ—§è®¾è®¡ï¼‰ | âŒ æœ‰ï¼ˆ5åˆ†é’Ÿçª—å£ï¼‰ | âœ… Order ID + Status | C |

### å»ä¸­å¿ƒåŒ–

| åè®® | éªŒè¯æ–¹å¼ | ä¿¡ä»»å‡è®¾ | è¯„çº§ |
|------|---------|---------|------|
| LayerZero | Oracle + Relayer | ä¿¡ä»» Oracle | B |
| Wormhole | 13/19 Guardian | ä¿¡ä»» Guardian å¤šæ•° | A |
| **æˆ‘ä»¬ï¼ˆSP1 ZKï¼‰** | **ZK è¯æ˜** | **ä¿¡ä»»æ•°å­¦** | **A+** |

### æ´»è·ƒæ€§

| åè®® | ä¿è¯æ–¹å¼ | å¤±è´¥å¤„ç† | è¯„çº§ |
|------|---------|---------|------|
| LayerZero | ç»æµæ¿€åŠ± | æ¶ˆæ¯å»¶è¿Ÿ | A |
| Wormhole | Guardian è´¨æŠ¼ | æ¶ˆæ¯å»¶è¿Ÿ | A+ |
| **æˆ‘ä»¬** | **Relayer æ¿€åŠ±** | **å…¬å…±ä¸­ç»§** | **A** |

---

## 8. æ–‡æ¡£æ›´æ–°æ¸…å•

- [x] åˆ›å»ºæœ¬å†³ç­–æ–‡æ¡£
- [ ] æ›´æ–° README.mdï¼ˆç§»é™¤è¶…æ—¶é€€æ¬¾è¯´æ˜ï¼‰
- [ ] æ›´æ–°æ¶æ„å›¾ï¼ˆç®€åŒ–çŠ¶æ€æœºï¼‰
- [ ] æ›´æ–° Phase 1.4 è®¡åˆ’ï¼ˆæ”¹ä¸º Relayer åŸºç¡€è®¾æ–½ï¼‰
- [ ] åˆ›å»º Relayer è¿ç»´æ–‡æ¡£
- [ ] æ›´æ–°ç”¨æˆ·æŒ‡å—ï¼ˆè¯´æ˜æ´»è·ƒæ€§ä¿è¯ï¼‰

---

## 9. æ€»ç»“

### å†³ç­–å›é¡¾

**æ”¾å¼ƒ**ï¼šè¶…æ—¶é€€æ¬¾æœºåˆ¶  
**åŸå› **ï¼šæ— æ³•æ¶ˆé™¤ç«æ€æ¡ä»¶é£é™©  
**æ›¿ä»£**ï¼šä¾èµ– Relayer ç½‘ç»œæ´»è·ƒæ€§ + ç»æµæ¿€åŠ±

### æ ¸å¿ƒä¼˜åŠ¿

1. âœ… **å®‰å…¨æ€§å¤§å¹…æå‡**ï¼ˆæ¶ˆé™¤åŒèŠ±é£é™©ï¼‰
2. âœ… **è®¾è®¡æ›´ç®€æ´**ï¼ˆ2 çŠ¶æ€ vs 3 çŠ¶æ€ï¼‰
3. âœ… **ä¸ä¸»æµåè®®ä¸€è‡´**ï¼ˆè¡Œä¸šæœ€ä½³å®è·µï¼‰
4. âœ… **ZK è¯æ˜ä¼˜åŠ¿**ï¼ˆæ¯” Oracle/Guardian æ›´å»ä¸­å¿ƒåŒ–ï¼‰

### ç”¨æˆ·ä½“éªŒä¿è¯

1. âœ… å¤š Relayer å†—ä½™ï¼ˆé¿å…å•ç‚¹æ•…éšœï¼‰
2. âœ… å®æ—¶çŠ¶æ€æŸ¥è¯¢ï¼ˆé€æ˜åŒ–ï¼‰
3. âœ… å…¬å…±ä¸­ç»§æœºåˆ¶ï¼ˆæœ€åä¿éšœï¼‰
4. âœ… DAO ç´§æ€¥å–æ¶ˆï¼ˆæç«¯æƒ…å†µï¼‰

### ä¸‹ä¸€æ­¥

**Phase 1.4**: å®ç° Relayer åŸºç¡€æ¶æ„
- Relayer æ‰‹ç»­è´¹
- è®¢å•æŸ¥è¯¢ API
- åŸºç¡€ç›‘æ§

**Phase 2+**: å»ä¸­å¿ƒåŒ–æ¼”è¿›
- æ— éœ€è®¸å¯çš„ Relayer ç½‘ç»œ
- è´¨æŠ¼å’Œæƒ©ç½šæœºåˆ¶
- ä¿¡èª‰ç³»ç»Ÿ

---

**è¿™æ˜¯æ›´å®‰å…¨ã€æ›´ä¸“ä¸šçš„è®¾è®¡ï¼** ğŸ¯
