# è¶…æ—¶å›æ»šç«æ€æ¡ä»¶é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

> âš ï¸ **é‡è¦æ›´æ–° (2025-11-01)**: 
> 
> ç»è¿‡æ·±å…¥åˆ†æå’Œä¸ LayerZero/Wormhole è®¾è®¡å¯¹æ¯”ï¼Œæˆ‘ä»¬å†³å®š **å½»åº•å–æ¶ˆè¶…æ—¶é€€æ¬¾æœºåˆ¶**ã€‚
> 
> æœ¬æ–‡æ¡£ä¿ç•™ä½œä¸ºæŠ€æœ¯åˆ†æå‚è€ƒï¼Œä½† **ä¸å†å®æ–½æ–‡æ¡£ä¸­çš„ä»»ä½•é€€æ¬¾æ–¹æ¡ˆ**ã€‚
> 
> æ–°çš„è®¾è®¡æ–¹æ¡ˆè¯·å‚è€ƒï¼š[å–æ¶ˆè¶…æ—¶é€€æ¬¾æœºåˆ¶çš„è®¾è®¡å†³ç­–](./12-å–æ¶ˆè¶…æ—¶é€€æ¬¾æœºåˆ¶çš„è®¾è®¡å†³ç­–.md)

---

## é—®é¢˜æè¿°

### åœºæ™¯ï¼šæ…¢é€Ÿ Relayer å¯¼è‡´çš„åŒèŠ±æ”»å‡»

**æ—¶é—´çº¿**ï¼š
```
T0  (slot 0):     ç”¨æˆ·åœ¨ Solana é”å®š 100 tokens
                  è®¢å•çŠ¶æ€: Pending
                  Vault: +100 tokens

T1  (slot 100):   Relayer å¼€å§‹ç”Ÿæˆ ZK è¯æ˜ï¼ˆè®¡ç®—é€Ÿåº¦æ…¢ï¼‰

T2  (slot 1200):  â° Solana è¶…æ—¶æ—¶é—´åˆ°è¾¾
                  ç”¨æˆ·è°ƒç”¨ refund_timeout()
                  è®¢å•çŠ¶æ€: Pending â†’ Refunded
                  Vault: -100 tokens (é€€æ¬¾ç»™ç”¨æˆ·)
                  ç”¨æˆ· Solana ä½™é¢: +100 tokens âœ…

T3  (slot 1500):  Relayer ç»ˆäºå®Œæˆ ZK è¯æ˜ç”Ÿæˆ

T4  (slot 1600):  Relayer åœ¨ EVM é“¾è°ƒç”¨ unlock()
                  éªŒè¯é€šè¿‡ï¼ˆè¯æ˜æœ¬èº«æ˜¯æœ‰æ•ˆçš„ï¼ï¼‰
                  EVM é“¾é“¸é€  100 tokens ç»™ç”¨æˆ· âœ…
                  
**ç»“æœï¼šç”¨æˆ·è·å¾—åŒå€ä»£å¸ï¼**
- Solana é€€æ¬¾: 100 tokens
- EVM é“¸é€ :   100 tokens
- æ€»è®¡:       200 tokens ğŸ’°ğŸ’° (åŒèŠ±ï¼)
```

### é—®é¢˜æ ¹æº

1. **æºé“¾å’Œç›®æ ‡é“¾çŠ¶æ€ä¸åŒæ­¥**
   - Solana ä¸Šè®¢å•å·² Refunded
   - EVM é“¾ä¸çŸ¥é“ Solana çŠ¶æ€å˜åŒ–
   - ZK è¯æ˜åªè¯æ˜"è¿‡å»æŸæ—¶åˆ»ä»£å¸è¢«é”å®š"

2. **è¯æ˜ä¸åŒ…å«æœ€æ–°çŠ¶æ€**
   - è¯æ˜ç”Ÿæˆæ—¶è®¢å•æ˜¯ Pendingï¼ˆâœ… æœ‰æ•ˆï¼‰
   - è¯æ˜æäº¤æ—¶è®¢å•æ˜¯ Refundedï¼ˆâŒ ä½†è¯æ˜ä¸çŸ¥é“ï¼‰
   - EVM é“¾æ— æ³•éªŒè¯"å½“å‰"çŠ¶æ€

3. **æ—¶é—´çª—å£ç«äº‰**
   - è¶…æ—¶ååˆ°è¯æ˜æäº¤ä¹‹é—´å­˜åœ¨ç«äº‰çª—å£
   - Relayer å¯ä»¥æ¶æ„åˆ©ç”¨ï¼ˆæˆ–æ„å¤–è§¦å‘ï¼‰

---

## è§£å†³æ–¹æ¡ˆå¯¹æ¯”

### æ–¹æ¡ˆ 1ï¼šæ—¶é—´çª—å£é™åˆ¶ â­ (Phase 1 æ¨è)

**è®¾è®¡**ï¼š
- Solana è¶…æ—¶æ—¶é—´ï¼š10 åˆ†é’Ÿï¼ˆç”¨æˆ·å¯é€€æ¬¾ï¼‰
- EVM è¯æ˜æœ‰æ•ˆæœŸï¼š15 åˆ†é’Ÿï¼ˆæ‹’ç»è¿‡æœŸè¯æ˜ï¼‰
- ç«äº‰çª—å£ï¼š5 åˆ†é’Ÿ

**å®ç°**ï¼š

```rust
// ========== Solana ç«¯ ==========
#[account]
pub struct BridgeConfig {
    pub timeout_slots: u64,  // 1200 slots â‰ˆ 10 åˆ†é’Ÿ
    // ... å…¶ä»–å­—æ®µ
}

#[account]
pub struct TransferOrder {
    pub created_slot: u64,     // è®¢å•åˆ›å»ºæ—¶é—´
    pub refunded_slot: u64,    // é€€æ¬¾æ—¶é—´ï¼ˆæ–°å¢ï¼‰
    // ... å…¶ä»–å­—æ®µ
}

pub fn refund_timeout(ctx: Context<RefundTimeout>) -> Result<()> {
    let order = &mut ctx.accounts.order;
    let clock = Clock::get()?;
    
    // 1. æ£€æŸ¥è¶…æ—¶
    require!(
        clock.slot >= order.created_slot + ctx.accounts.bridge_config.timeout_slots,
        BridgeError::OrderNotTimedOut
    );
    
    // 2. æ£€æŸ¥çŠ¶æ€
    require!(
        order.status == OrderStatus::Pending,
        BridgeError::OrderNotPending
    );
    
    // 3. è®°å½•é€€æ¬¾æ—¶é—´ï¼ˆå…³é”®ï¼ï¼‰
    order.refunded_slot = clock.slot;
    
    // 4. æ‰§è¡Œé€€æ¬¾
    // ... transfer from vault to user
    
    order.status = OrderStatus::Refunded;
    
    emit!(TokensRefunded {
        order_id: order.order_id,
        user: order.user,
        amount: order.amount,
        refunded_slot: clock.slot,  // å…³é”®ï¼šè®°å½•æ—¶é—´
    });
    
    Ok(())
}
```

```solidity
// ========== EVM ç«¯ ==========
contract SolanaEvmBridge {
    uint256 public constant PROOF_MAX_AGE = 15 minutes;  // è¯æ˜æœ€å¤§å¹´é¾„
    uint256 public constant SOURCE_TIMEOUT = 10 minutes;  // Solana è¶…æ—¶
    uint256 public constant SOLANA_SLOT_TIME = 500;  // æ¯ä¸ª slot â‰ˆ 0.5 ç§’
    
    struct Order {
        uint64 orderId;
        address user;
        uint256 amount;
        OrderStatus status;
        uint64 sourceChainSlot;  // Solana åˆ›å»ºæ—¶çš„ slot
    }
    
    function unlockTokens(
        uint64 orderId,
        bytes32 proofHash,
        uint64 sourceChainSlot,  // è¯æ˜ç”Ÿæˆæ—¶çš„ Solana slot
        bytes calldata proof
    ) external {
        Order storage order = orders[orderId];
        require(order.status == OrderStatus.Pending, "Not pending");
        
        // 1. éªŒè¯ ZK è¯æ˜
        require(verifyProof(proof, proofHash), "Invalid proof");
        
        // 2. å…³é”®ï¼šæ£€æŸ¥è¯æ˜æ—¶æ•ˆæ€§
        uint256 slotAge = block.timestamp - (sourceChainSlot * SOLANA_SLOT_TIME / 1000);
        require(slotAge < PROOF_MAX_AGE, "Proof too old");
        
        // 3. é¢å¤–æ£€æŸ¥ï¼šè¯æ˜å¿…é¡»åœ¨è¶…æ—¶çª—å£å†…
        require(slotAge < SOURCE_TIMEOUT + 5 minutes, "Beyond safety window");
        
        // 4. æ‰§è¡Œé“¸é€ 
        order.status = OrderStatus.Completed;
        _mint(order.user, order.amount);
        
        emit TokensUnlocked(orderId, order.user, order.amount);
    }
}
```

**ä¼˜ç‚¹**ï¼š
- âœ… å®ç°ç®€å•
- âœ… ä¿æŠ¤è¯šå® Relayerï¼ˆæœ‰ 5 åˆ†é’Ÿç¼“å†²ï¼‰
- âœ… ä¿æŠ¤ç”¨æˆ·ï¼ˆ10 åˆ†é’Ÿå¯é€€æ¬¾ï¼‰
- âœ… é€‚åˆ Phase 1

**ç¼ºç‚¹**ï¼š
- âš ï¸ ä»å­˜åœ¨ 5 åˆ†é’Ÿç«äº‰çª—å£
- âš ï¸ ä¾èµ–æ—¶é’ŸåŒæ­¥
- âš ï¸ æ¶æ„ Relayer ä»å¯èƒ½åŒèŠ±ï¼ˆæ¦‚ç‡ä½ï¼‰

**é€‚ç”¨åœºæ™¯**ï¼š
- æ—©æœŸæµ‹è¯•ç½‘
- Relayer å¯ä¿¡æˆ–æœ‰å£°èª‰æœºåˆ¶
- å¯æ¥å—å°é¢é£é™©

---

### æ–¹æ¡ˆ 2ï¼šæŒ‘æˆ˜æœŸæœºåˆ¶ â­â­ (Phase 2 æ¨è)

**è®¾è®¡**ï¼š
- é€€æ¬¾åè¿›å…¥ 24 å°æ—¶æŒ‘æˆ˜æœŸ
- Relayer å¯ä»¥æäº¤è¯æ˜"æŒ‘æˆ˜"é€€æ¬¾
- éœ€è¦ç”¨æˆ·è´¨æŠ¼æˆ–æˆæƒæ‰£å›

**å®ç°**ï¼š

```rust
// ========== Solana ç«¯ ==========
#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum OrderStatus {
    Pending,
    Completed,
    Refunded,
    RefundChallenged,  // æ–°å¢ï¼šé€€æ¬¾è¢«æŒ‘æˆ˜
}

#[account]
pub struct TransferOrder {
    pub created_slot: u64,
    pub refunded_slot: u64,
    pub challenge_deadline_slot: u64,  // æŒ‘æˆ˜æœŸæˆªæ­¢
    // ... å…¶ä»–å­—æ®µ
}

pub const CHALLENGE_PERIOD_SLOTS: u64 = 172800; // 24 å°æ—¶

pub fn refund_timeout(ctx: Context<RefundTimeout>) -> Result<()> {
    let order = &mut ctx.accounts.order;
    let clock = Clock::get()?;
    
    // è¶…æ—¶æ£€æŸ¥
    require!(
        clock.slot >= order.created_slot + ctx.accounts.bridge_config.timeout_slots,
        BridgeError::OrderNotTimedOut
    );
    
    // æ‰§è¡Œé€€æ¬¾
    // ... transfer from vault to user
    
    // è®¾ç½®æŒ‘æˆ˜æœŸ
    order.refunded_slot = clock.slot;
    order.challenge_deadline_slot = clock.slot + CHALLENGE_PERIOD_SLOTS;
    order.status = OrderStatus::Refunded;
    
    msg!("Refunded, challenge period until slot {}", order.challenge_deadline_slot);
    
    Ok(())
}

pub fn challenge_refund(
    ctx: Context<ChallengeRefund>,
    proof_hash: [u8; 32],
) -> Result<()> {
    let order = &mut ctx.accounts.order;
    let clock = Clock::get()?;
    
    // 1. æ£€æŸ¥è®¢å•çŠ¶æ€
    require!(
        order.status == OrderStatus::Refunded,
        BridgeError::OrderNotRefunded
    );
    
    // 2. æ£€æŸ¥ä»åœ¨æŒ‘æˆ˜æœŸå†…
    require!(
        clock.slot <= order.challenge_deadline_slot,
        BridgeError::ChallengePeriodExpired
    );
    
    // 3. éªŒè¯è¯æ˜
    require!(proof_hash != [0u8; 32], BridgeError::InvalidProof);
    order.proof_hash = proof_hash;
    
    // 4. ä»ç”¨æˆ·æ‰£å›ä»£å¸ï¼ˆéœ€è¦ç”¨æˆ·æˆæƒæˆ–è´¨æŠ¼ï¼‰
    let transfer_ctx = CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        Transfer {
            from: ctx.accounts.user_token_account.to_account_info(),
            to: ctx.accounts.vault.to_account_info(),
            authority: ctx.accounts.user.to_account_info(),
        },
    );
    token::transfer(transfer_ctx, order.amount)?;
    
    // 5. æ›´æ–°çŠ¶æ€
    order.status = OrderStatus::RefundChallenged;
    
    emit!(RefundChallenged {
        order_id: order.order_id,
        challenger: ctx.accounts.relayer.key(),
        proof_hash,
    });
    
    // 6. é€šçŸ¥ EVM é“¾ç»§ç»­é“¸é€ 
    // (éœ€è¦è·¨é“¾æ¶ˆæ¯æœºåˆ¶)
    
    Ok(())
}
```

**ä¼˜ç‚¹**ï¼š
- âœ… å®Œå…¨é˜²æ­¢åŒèŠ±
- âœ… ä¿æŠ¤è¯šå® Relayer
- âœ… å¯éªŒè¯æ€§å¼º

**ç¼ºç‚¹**ï¼š
- âŒ ç”¨æˆ·ä½“éªŒå·®ï¼ˆé€€æ¬¾å¯èƒ½è¢«æ’¤é”€ï¼‰
- âŒ éœ€è¦ç”¨æˆ·è´¨æŠ¼æˆ–æˆæƒ
- âŒ å®ç°å¤æ‚
- âŒ éœ€è¦è·¨é“¾çŠ¶æ€åŒæ­¥

**é€‚ç”¨åœºæ™¯**ï¼š
- é«˜ä»·å€¼èµ„äº§è·¨é“¾
- å»ä¸­å¿ƒåŒ– Relayer ç½‘ç»œ
- éœ€è¦æœ€é«˜å®‰å…¨æ€§

---

### æ–¹æ¡ˆ 3ï¼šZK è¯æ˜åŒ…å«çŠ¶æ€æ ¹ â­â­â­ (ç»ˆææ–¹æ¡ˆ)

**è®¾è®¡**ï¼š
- ZK è¯æ˜ä¸ä»…è¯æ˜"ä»£å¸è¢«é”å®š"
- è¿˜è¯æ˜"è®¢å•å½“å‰çŠ¶æ€ä¸º Pending"
- é€šè¿‡ Merkle æ ‘è¯æ˜æºé“¾æœ€æ–°çŠ¶æ€

**å®ç°**ï¼š

```rust
// ========== SP1 Guest Program (ZK ç”µè·¯) ==========
use sp1_zkvm::prelude::*;

#[derive(Serialize, Deserialize)]
pub struct ProofPublicValues {
    pub order_id: u64,
    pub amount: u64,
    pub recipient: [u8; 20],
    pub source_state_root: [u8; 32],  // Solana çŠ¶æ€æ ¹
    pub order_status: u8,              // å¿…é¡»æ˜¯ Pending = 0
    pub timestamp_slot: u64,
}

pub fn main() {
    // 1. è¯»å–æºé“¾çŠ¶æ€æ ¹
    let state_root: [u8; 32] = sp1_zkvm::io::read();
    
    // 2. è¯»å–è®¢å• Merkle è¯æ˜
    let order_proof: MerkleProof = sp1_zkvm::io::read();
    let order: TransferOrder = sp1_zkvm::io::read();
    
    // 3. éªŒè¯è®¢å•å­˜åœ¨äºçŠ¶æ€æ ‘ä¸­
    assert!(verify_merkle_proof(
        &order_proof,
        &state_root,
        &hash_order(&order)
    ), "Order not in state");
    
    // 4. å…³é”®ï¼šéªŒè¯è®¢å•çŠ¶æ€ä¸º Pending
    assert!(order.status == OrderStatus::Pending, "Order not pending");
    
    // 5. è¾“å‡º public values
    sp1_zkvm::io::commit(&ProofPublicValues {
        order_id: order.order_id,
        amount: order.amount,
        recipient: order.recipient,
        source_state_root: state_root,
        order_status: order.status as u8,
        timestamp_slot: get_current_slot(),
    });
}
```

```solidity
// ========== EVM ç«¯ ==========
contract SolanaEvmBridge {
    ISP1Verifier public sp1Verifier;
    
    struct ProofPublicValues {
        uint64 orderId;
        uint256 amount;
        address recipient;
        bytes32 sourceStateRoot;
        uint8 orderStatus;  // å¿…é¡»æ˜¯ 0 (Pending)
        uint64 timestampSlot;
    }
    
    function unlockTokens(
        bytes calldata proof,
        ProofPublicValues calldata publicValues
    ) external {
        // 1. éªŒè¯ ZK è¯æ˜
        require(
            sp1Verifier.verify(proof, abi.encode(publicValues)),
            "Invalid ZK proof"
        );
        
        // 2. å…³é”®ï¼šæ£€æŸ¥è®¢å•çŠ¶æ€å¿…é¡»æ˜¯ Pending
        require(
            publicValues.orderStatus == 0,  // Pending
            "Order not pending in source chain"
        );
        
        // 3. æ£€æŸ¥çŠ¶æ€æ ¹çš„æ—¶æ•ˆæ€§ï¼ˆå¯é€‰ï¼‰
        require(
            block.timestamp - slotToTimestamp(publicValues.timestampSlot) < 1 hours,
            "State root too old"
        );
        
        // 4. æ£€æŸ¥è®¢å•æœªè¢«å¤„ç†
        Order storage order = orders[publicValues.orderId];
        require(order.status == OrderStatus.Pending, "Already processed");
        
        // 5. æ‰§è¡Œé“¸é€ 
        order.status = OrderStatus.Completed;
        _mint(publicValues.recipient, publicValues.amount);
        
        emit TokensUnlocked(
            publicValues.orderId,
            publicValues.recipient,
            publicValues.amount,
            publicValues.sourceStateRoot
        );
    }
}
```

**ä¼˜ç‚¹**ï¼š
- âœ… çœŸæ­£çš„å»ä¸­å¿ƒåŒ–
- âœ… å®Œå…¨é˜²æ­¢åŒèŠ±
- âœ… ä¸ä¾èµ–æ—¶é—´çª—å£
- âœ… ç¬¦åˆ ZK æ¡¥è®¾è®¡ç†å¿µ
- âœ… æœ€é«˜å®‰å…¨æ€§

**ç¼ºç‚¹**ï¼š
- âŒ å®ç°å¤æ‚
- âŒ éœ€è¦å®Œæ•´ SP1 é›†æˆ
- âŒ è¯æ˜ç”Ÿæˆæ›´æ…¢ï¼ˆåŒ…å« Merkle è¯æ˜ï¼‰
- âŒ Gas æ¶ˆè€—æ›´é«˜

**é€‚ç”¨åœºæ™¯**ï¼š
- ç”Ÿäº§ç¯å¢ƒ
- å¤§é¢èµ„äº§è·¨é“¾
- å»ä¸­å¿ƒåŒ–è¦æ±‚é«˜
- Phase 6+ å®Œæ•´å®ç°

---

## æ¨èå®æ–½è·¯çº¿å›¾

### Phase 1.4ï¼ˆå½“å‰ï¼‰ï¼šæ–¹æ¡ˆ 1 - åŸºç¡€æ—¶é—´çª—å£

```
å®ç°ï¼š
âœ… refund_timeout åŸºç¡€åŠŸèƒ½
âœ… è®°å½• refunded_slot
âš ï¸ æ–‡æ¡£æ ‡æ³¨é£é™©çª—å£

æµ‹è¯•ï¼š
- æ­£å¸¸è¶…æ—¶é€€æ¬¾
- è¾¹ç•Œæƒ…å†µï¼ˆåˆšå¥½ 1200 slotsï¼‰
- æ–‡æ¡£è¯´æ˜ 5 åˆ†é’Ÿé£é™©çª—å£
```

### Phase 2ï¼šEVM åˆçº¦ + æ—¶é—´éªŒè¯

```
å®ç°ï¼š
âœ… EVM ç«¯åŸºç¡€åˆçº¦
âœ… è¯æ˜æ—¶æ•ˆæ€§æ£€æŸ¥
âœ… slotToTimestamp è½¬æ¢

æµ‹è¯•ï¼š
- è¿‡æœŸè¯æ˜æ‹’ç»
- ç«äº‰çª—å£æµ‹è¯•
```

### Phase 6ï¼šå®Œæ•´ SP1 é›†æˆ + çŠ¶æ€è¯æ˜

```
å®ç°ï¼š
âœ… SP1 Guest Program
âœ… çŠ¶æ€æ ¹ Merkle è¯æ˜
âœ… è®¢å•çŠ¶æ€éªŒè¯
âœ… å®Œæ•´å»ä¸­å¿ƒåŒ–

æµ‹è¯•ï¼š
- ç«¯åˆ°ç«¯ ZK è¯æ˜
- çŠ¶æ€åŒæ­¥éªŒè¯
```

---

## Phase 1.4 éœ€è¦çš„ä¿®æ”¹

### 1. æ›´æ–° TransferOrder ç»“æ„

```rust
#[account]
pub struct TransferOrder {
    pub order_id: u64,
    pub user: Pubkey,
    pub source_chain: u8,
    pub token_config: Pubkey,
    pub amount: u64,
    pub recipient: [u8; 20],
    pub relayer_fee: u64,
    pub created_slot: u64,
    pub status: OrderStatus,
    pub proof_hash: [u8; 32],
    pub refunded_slot: u64,  // æ–°å¢ï¼šè®°å½•é€€æ¬¾æ—¶é—´
}

// æ›´æ–° space è®¡ç®—
// 8 + 8 + 32 + 1 + 32 + 8 + 20 + 8 + 8 + 1 + 32 + 8 = 166
```

### 2. å®ç° refund_timeout

```rust
pub fn refund_timeout(ctx: Context<RefundTimeout>) -> Result<()> {
    let order = &mut ctx.accounts.order;
    let clock = Clock::get()?;
    
    // æ£€æŸ¥è¶…æ—¶
    require!(
        clock.slot >= order.created_slot + ctx.accounts.bridge_config.timeout_slots,
        BridgeError::OrderNotTimedOut
    );
    
    // æ£€æŸ¥çŠ¶æ€
    require!(
        order.status == OrderStatus::Pending,
        BridgeError::OrderNotPending
    );
    
    // è®°å½•é€€æ¬¾æ—¶é—´ï¼ˆå…³é”®ï¼ï¼‰
    order.refunded_slot = clock.slot;
    
    // PDA ç­¾åé€€æ¬¾
    let seeds = &[
        b"bridge_config".as_ref(),
        &[ctx.bumps.bridge_config],
    ];
    let signer_seeds = &[&seeds[..]];
    
    let transfer_ctx = CpiContext::new_with_signer(
        ctx.accounts.token_program.to_account_info(),
        Transfer {
            from: ctx.accounts.vault.to_account_info(),
            to: ctx.accounts.user_token_account.to_account_info(),
            authority: ctx.accounts.bridge_config.to_account_info(),
        },
        signer_seeds,
    );
    token::transfer(transfer_ctx, order.amount)?;
    
    // æ›´æ–°çŠ¶æ€
    order.status = OrderStatus::Refunded;
    ctx.accounts.token_config.total_locked -= order.amount;
    
    emit!(TokensRefunded {
        order_id: order.order_id,
        user: order.user,
        amount: order.amount,
        refunded_slot: clock.slot,
    });
    
    Ok(())
}
```

### 3. åœ¨æ–‡æ¡£ä¸­æ ‡æ³¨é£é™©

```markdown
## âš ï¸ å·²çŸ¥é™åˆ¶ï¼ˆPhase 1ï¼‰

### ç«äº‰çª—å£é£é™©

- Solana è¶…æ—¶ï¼š1200 slots (â‰ˆ10 åˆ†é’Ÿ)
- EVM è¯æ˜æœ‰æ•ˆæœŸï¼š15 åˆ†é’Ÿï¼ˆè®¡åˆ’ï¼‰
- **ç«äº‰çª—å£ï¼š5 åˆ†é’Ÿ**

åœ¨è¿™ 5 åˆ†é’Ÿå†…ï¼š
- ç”¨æˆ·å·²åœ¨ Solana è·å¾—é€€æ¬¾
- Relayer ä»å¯åœ¨ EVM æäº¤æœ‰æ•ˆè¯æ˜
- å¯èƒ½å¯¼è‡´åŒèŠ±

**ç¼“è§£æªæ–½**ï¼š
1. é€‰æ‹©å¯ä¿¡ Relayer
2. ç›‘æ§å¼‚å¸¸è¡Œä¸º
3. Phase 6 å°†å®ç°å®Œæ•´çŠ¶æ€è¯æ˜
```

---

## æ€»ç»“

| æ–¹æ¡ˆ | å®‰å…¨æ€§ | å¤æ‚åº¦ | ç”¨æˆ·ä½“éªŒ | æ¨èé˜¶æ®µ |
|------|--------|--------|----------|----------|
| æ–¹æ¡ˆ 1ï¼šæ—¶é—´çª—å£ | â­â­â­ | â­ | â­â­â­â­ | Phase 1-2 |
| æ–¹æ¡ˆ 2ï¼šæŒ‘æˆ˜æœŸ | â­â­â­â­ | â­â­â­ | â­â­ | Phase 3-5 |
| æ–¹æ¡ˆ 3ï¼šZK çŠ¶æ€è¯æ˜ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | Phase 6+ |

**å½“å‰ Phase 1.4 å»ºè®®**ï¼š
- âœ… å®ç°æ–¹æ¡ˆ 1
- âœ… æ·»åŠ  refunded_slot å­—æ®µ
- âœ… æ–‡æ¡£æ ‡æ³¨é£é™©çª—å£
- âœ… ä¸º EVM ç«¯é¢„ç•™æ—¶æ•ˆæ€§æ£€æŸ¥æ¥å£
- âš ï¸ æ˜ç¡®æ ‡æ³¨"æµ‹è¯•ç½‘é˜¶æ®µ"
